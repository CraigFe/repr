type 'a typ = 'a Repr.Type.t
module Trivial :
  sig
    type t[@@deriving repr]
    include sig val t : t Repr.Type.t end[@@ocaml.doc "@inline"][@@merlin.hide
                                                                  ]
  end =
  struct
    type t = int as 'a[@@deriving repr]
    include struct let t = Repr.Type.int end[@@ocaml.doc "@inline"][@@merlin.hide
                                                                    ]
  end 
module Recursive :
  sig
    type 'a tree[@@deriving repr]
    include sig val tree_t : 'a Repr.Type.t -> 'a tree Repr.Type.t end
    [@@ocaml.doc "@inline"][@@merlin.hide ]
  end =
  struct
    type 'a tree =
      [ `Branch of ('tree * int * 'tree)  | `Leaf of 'a ] as 'tree[@@deriving
                                                                    repr]
    include
      struct
        let tree_t a =
          Repr.Type.mu
            (fun tree ->
               Repr.Type.sealv
                 (Repr.Type.(|~)
                    (Repr.Type.(|~)
                       (Repr.Type.variant "tree"
                          (fun branch ->
                             fun leaf ->
                               function
                               | `Branch x1 -> branch x1
                               | `Leaf x1 -> leaf x1))
                       (Repr.Type.case1 "Branch"
                          (Repr.Type.triple tree Repr.Type.int tree)
                          (fun x1 -> `Branch x1)))
                    (Repr.Type.case1 "Leaf" a (fun x1 -> `Leaf x1))))
      end[@@ocaml.doc "@inline"][@@merlin.hide ]
  end 
